Les questions se basent sur une version PHP 7.

1. A quoi sert "continue" à l'intérieur d'une boucle "for" ou "foreach" ?

1.	sort de la boucle itérative
2.	demande a poursuivre le code même en cas d'erreur
3.	cette instruction n'existe pas en PHP
4.	passe à l'itération suivante

Réponse : 4. Passe à l'itération suivante

Explication : L'instruction continue permet de sauter le reste du code de l'itération en cours pour passer directement à la suivante.

2. Quelle fonction de bufferisation (temporisation) envoie au navigateur les données contenues par le tampon, et stoppe la tamporisation de sortie ?

1.	ob_flush()
2.	ob_end_flush()
3.	ob_get_flush()

Réponse : 2. ob_end_flush()

Explication : ob_end_flush() envoie le contenu du tampon (buffer) de sortie au navigateur et termine le processus de buffering.

3. Afin de se prévenir les attaques CSRF, quelles mesures peut on prendre ?
.
1.	Utiliser strip_tags()
2.	Ajouter un jeton unique dans chaque formulaire (token)
3.	Utiliser htmlspecialchars()
4.	Utiliser PDO (requêtes paramétées ) ou mysql_real_escape_string()

Réponse : 2. Ajouter un jeton unique dans chaque formulaire (token)

Explication : La protection CSRF se base principalement sur l’ajout d’un token (jeton) unique et imprévisible dans chaque formulaire. Cela garantit que seul l'utilisateur qui a généré le formulaire peut l'envoyer, réduisant ainsi les risques d'attaques via des requêtes non autorisées.

4. Que se passe-t-il lors de l’exécution de ce script

<?php
$value = [];
foreach($value as $val) {
               echo $val;
}
1.	Cela provoque une erreur PHP
2.	Cela provoque une notice PHP
3.	Aucun des deux

Réponse : 3. Aucun des deux

Explication : Ce code ne génère ni erreur ni notice, car foreach sur un tableau vide ne fait tout simplement rien. PHP ignore le corps de la boucle.

5. Quelle est la principale différence entre les fonctions PHP isset() et array_key_exists() lorsque l'on vérifie si un élément existe dans un tableau ?

1.	array_key_exists() est beaucoup plus rapide pour les tableaux
2.	isset() créera une valeur valeur vide dans le tableau si la clé n'existe pas
3.	isset() lévera un avertissement PHP si la clé n'existe pas
4.	isset() renvera false si la clé existe, mais que sa valeur est null

Réponse : 4. isset() renverra false si la clé existe, mais que sa valeur est null

Explication : isset() vérifie que la clé existe et que sa valeur n'est pas null, alors qu’array_key_exists() vérifie uniquement la présence de la clé, indépendamment de sa valeur. 

6. Que va afficher le code suivant : <?php echo count(false); ?>
1. 0
2. 1
3. Une erreur de type warning est déclenchée
4. Une erreur fatale est déclenchée

Réponse : 1

Explication : En PHP, count(false) retourne 0 car false est traité comme une valeur vide ou un tableau vide pour count().

7. A quoi servent les classes de type Reflection?
1. A faire une introspection sur des classes, méthodes et fonctions ou encore de récupérer des blocs de commentaires.
2. A cloner une variable
3. A faire une pause dans l'exécution d'un script
4. A afficher des données

Réponse : 1. À faire une introspection sur des classes, méthodes, et fonctions, ou encore pour récupérer des blocs de commentaires

8. Que fait la fonction unset() ?
1. Elle permet de supprimer un fichier
2. Elle permet de supprimer un répertoire
3. Elle permet de détruire une variable
4. Elle n'existe pas

Réponse : 3. Elle permet de détruire une variable
Explication : unset() supprime une variable de la mémoire.

9. Qu'est-ce que le cast d'une variable ?
1. Ca permet de rendre une variable globale
2. Ca permet de détruire une variable
3. Ca permet de changer le type d'une variable
4. Ca permet d'afficher le contenu d'une variable

Réponse : 3. Ça permet de changer le type d'une variable

Explication : Le cast permet de forcer une variable à adopter un autre type (par exemple de string à int).

10. Que va afficher le code suivant : <?php echo '100' === 100 ? 'Identique' : 'Différent'; ?>
1. Identique
2. Différent
3. Rien
4. Il y a une erreur de syntaxe

Réponse : 2. Différent

Explication : L'opérateur === vérifie à la fois la valeur et le type. Ici, '100' est une chaîne (string), tandis que 100 est un entier (int). Puisque les types sont différents, la condition est false, donc PHP affiche Différent.